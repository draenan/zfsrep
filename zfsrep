#!/bin/sh -
#
# $Id: zfsrep,v 1.8 2012/04/07 13:31:45 awaters Exp $
#
############################################################################
#
# zfsrep
#
# Usage: zfsrep [-m] [-S] -s snapname srcpool destpool
#
# This script automates incremental ZFS snapshot replication, but is really
# specific to my particular setup; hence the "-m Import destination pool"
# option utilizes camcontrol(8) to attach my external destination pool
# via eSATA in a way that is particular to my particular setup. Curse
# non-hot-swappable IDE/ATAPI controllers masquerading as eSATA; cheapest
# bidder for Microserver components, HP?
#
# If '-m' was specified and the import successfuly, the pool will be
# exported prior to script exit, unless "-S" was specified, in which case
# the pool will be scrubbed and left online for a human to check the status
# later.  If '-m' is not specified, the script will exit if the pool is not
# already imported, and will not export the pool if the pool was mounted.
#
# "snapname" is more a "type" (eg "weekly") than the actual full name as
# there are likely more than one snapshot of a particular type. Hence
# the whole idea of an script that works on incremental snapshots.
#
# Assumption: This script will be used to replicate online pools. If
#             "srcpool" is not online the script will exit. Checks for
#             an online state may be considered inadequate in the script's
#             current state.  The script also requires you to be running
#             FreeBSD 9 or higher; it is untested on FreeBSD 8, nor is it
#             tested on Solaris.
#
# Author: Adrian Waters <awaters@draenan.net>
#
############################################################################

IFS=' 	
'
PATH=/bin:/usr/bin

progname=${0##*/}

usage () {
    echo "Usage: $progname [-m] [-S] -s snapname srcpool destpool" >&2
    exit 1
}


# The expool function will either kick off a scrub of the destination pool,
# or export the pool, depending on the options chosen by the user.

expool () {
    if [ ! -z "$scrubdest" ]; then
        imported=
        $ZFS scrub $destpool
    else
        if [ ! -z "$imported" ]; then
        $ZPOOL export $destpool > /dev/null 2>&1
            if [ "$?" -ne "0" ]; then
                echo "$progname: Could not export \"$destpool\". Exiting." >&2
                exit 1
            fi
        fi
    fi
}

# There isn't any reason that I can think of why this script wouldn't work on
# FreeBSD RELENG_8 or Solaris 10+, I simply haven't tested it. Plus the
# pool-mounting logic is *very* specific to my own FreeBSD 9 system and its
# non-hot-pluggable eSATA controller.

case $(/usr/bin/uname -sr) in
    "FreeBSD 9"*)
        ID=/usr/bin/id
        CAMCONTROL=/sbin/camcontrol
        GREP=/usr/bin/grep
        ZPOOL=/sbin/zpool
        ZFS=/sbin/zfs
        DATE=/bin/date
        AWK=/usr/bin/awk
        SED=/usr/bin/sed
        ;;
    *)
        echo "$progname: FreeBSD 9.0-RELEASE and above only." >&2
        exit 1
        ;;
esac

# Ensure we have the correct number of arguments, and are running as root.

if [ "$#" -lt 4 ]; then
    usage
fi

if [ $($ID -u) -ne "0" ]; then
    echo "You need to be root." >&2
    exit 1
fi

# Gather the arguments.

scrubdest= snapname= import= srcpool= destpool=

while getopts :mSs: opt; do
    case $opt in
        S)
            scrubdest=1
            ;;
        s)
            snapname=$OPTARG
            ;;
        m)
            import=1
            imported=
            ;;
        '?')
            usage
            ;;
    esac
done

shift $((OPTIND - 1))

srcpool=$1
destpool=$2

# All three of "srcpool", "destpool", and "snapname" must be provided.

if [ -z "$srcpool" -o -z "$destpool" -o -z "$snapname" ]; then
    usage
    exit 1
fi

# Sanitize the input for "snapname."
#
# Note that the ":" character is valid for ZFS filesystem/snapshot names, 
# but will cause issues on FreeBSD if you are sharing that filesystem via
# userland Samba.  This problem does not exist on Solaris as CIFS sharing is
# integrated into the kernel and controlled via the ZFS "sharesmb" property,
# with ":" being automatically translated to "_".

echo $snapname | $GREP -E '^[[:alpha:]]' | $GREP -Ev '[^-_.:[:alnum:]]' > /dev/null 2>&1
if [ "$?" -eq "1" ]; then
    echo "$progname: \"$snapname\" is not a valid ZFS snapshot name." >&2
    exit 1
fi

# Sanitize the inputs for "srcpool" and "destpool".
#
# The script will not progress if the source pool is not available.  If the
# destination pool is unavailable an attempt will be made to import it (if
# requested via the "-m" option), otherwise the script will exit.

for pool in $srcpool $destpool; do
    echo $pool | $GREP -E '^[[:alpha:]]' | $GREP -Ev '^(c[0-9].*|mirror|raidz|spare|log)$|[^-_.[:alnum:]]' > /dev/null 2>&1
    if [ "$?" -eq "1" ]; then
        echo "$progname: \"$pool\" is not a valid ZFS pool name." >&2
        exit 1
    fi
    $ZPOOL list -H -o name $pool > /dev/null 2>&1
    if [ "$?" -ne "0" ]; then
        if [ "X$pool" == "X$srcpool" -o -z "$import" ]; then
           echo "$progname: \"$pool\" is not available. Exiting." >&2
           exit 1
        else
            $ZPOOL import $destpool > /dev/null 2>&1
            if [ "$?" -ne "0" ]; then

                # Interesting idea below, but ultimately pointless, and wrong if a USB
                # disk is plugged in. Hard-coding instead.
                #
                # This section of code will need to be isolated should I convert this
                # script to one suitable for systems other than my own.

                #busno=$($CAMCONTROL devlist | $AWK 'END { sub(/scbus/,""); print $5+1 }')
                busno=6
                ($CAMCONTROL reset $busno && $CAMCONTROL rescan $busno) > /dev/null 2>&1
                if [ "$?" -ne "0" ]; then
                    echo "$progname: Could not attach backup device on scbus$busno. Exiting." >&2
                    exit 1
                fi
                $ZPOOL import $destpool > /dev/null 2>&1
                if [ "$?" -ne "0" ]; then
                    echo "$progname: Could not import ZFS pool \"$destpool\". Exiting." >&2
                    exit 1
                fi
            fi
            imported=1
        fi
    fi
done

# Get a list of all snapshots that match "snapname" on the source and
# destination pools.  Compare the last snapshot on the source pool to the last
# replicated snapshot on the destination pool.  If the same, no need to do
# anything.

snaps=$($ZFS list -r -t snapshot -H -o name -s creation $srcpool | $GREP "$srcpool@$snapname" | $SED "s/$srcpool@//")
lastsnap=$(echo $snaps | $AWK '{ print $NF }')
lastrep=$($ZFS list -r -t snapshot -H -o name -s creation $destpool | $GREP "$destpool@$snapname" | $AWK -F@ 'END { print $NF }')

if [ "X$lastsnap" == "X$lastrep" ]; then
    echo "$progname: No new snapshots to send. Exiting." >&2
    expool
    exit 1
fi

# Check that the last replicated snapshot is still available on the source
# pool (unless there was no lastrep, in which case assume this is the first
# replication.)  If not (presumably because there is a rolling snapshot
# schedule in place and the replication hasn't happened in time for the last
# rep to fall off the list) don't do anything as we can't perform incremental
# replication from a non-existant source.

echo $snaps | $GREP $lastrep > /dev/null 2>&1
if [ "$?" -eq "0" ]; then
    start=$lastrep
else
    if [ ! -z "$lastrep" ]; then
        echo "$progname: The last-replicated snapshot \"$srcpool@$lastrep\" no longer exists. Exiting."
        expool
        exit 1
    fi  
fi

# Perform the snapshot replication between the source and destination pools.
# Once done, scrub or export the destination pool as required. Ideally I
# should check for errors here but can't currently think of how to retrieve
# exit codes from both sides of a pipe.

if [ -z "$lastrep" ]; then
    $ZFS send -R $srcpool@$lastsnap | $ZFS recv -d -F $destpool
else
    $ZFS send -R -I $srcpool@$start $srcpool@$lastsnap | $ZFS recv -d -F $destpool
fi  
$ZFS set readonly=on $destpool
expool
exit

# vi: set tabstop=4 shiftwidth=4 si ai nu:
